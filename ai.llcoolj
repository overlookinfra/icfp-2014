(asm abs "math/abs.gcc")
(asm % "math/mod.gcc")
(asm > "math/gt.gcc")
(asm >= "math/gte.gcc")
(asm = "math/eq.gcc")
(asm not "math/not.gcc")
(asm distance "distance.gcc")
(asm nth "nth.gcc")

(pos? [x]
  (> x 0))

(neg? [x]
  (< x 0))

(zero? [x]
  (= x 0))

(<= [x y]
  (>= y x))

(< [x y]
  (> y x))

(!= [x y]
  (not (= x y)))

(false? [val]
  (= val false))

(true? [val]
  (not (false? val)))

(empty? [val]
  (if (atom? val)
    (zero? val)
    false))

(append
  [l1 l2]
  (if (empty? l1)
    l2
    (cons (car l1)
          (append (cdr l1) l2))))

(pill? [cell]
  ;; "+ is or" -- branan
  (+ (= cell 2) (= cell 3)))

(wall?
  [cell]
  (= cell 0))

(movable?
  [cell]
  (not (wall? cell)))

(whereami [world]
  (nth (nth world 1) 1))

(make-coord [x y]
  (cons x y))

(to-the
  [dir coord]
  (cond
    (= dir up)
    (make-coord (x coord) (dec (y coord)))

    (= dir right)
    (make-coord (inc (x coord)) (y coord))

    (= dir down)
    (make-coord (x coord) (inc (y coord)))

    (= dir left)
    (make-coord (dec (x coord)) (y coord))))

;; Look n squares in dir from coord. This progressively looks more and more
;; squares out until it either sees a wall or reaches the limit. Result is
;; either wall or the contents of the space n squares away.
(look-to-the
  [dir coord distance]
  (def square-content (look-at (to-the dir coord)))
  (if (wall? square-content)
    ;; 0 == wall
    0
    (if (> distance 1)
      (look-to-the dir (to-the dir coord) (dec distance))
      square-content)))

(filter [pred coll]
  (if (empty? coll)
    coll
    (if (pred (car coll))
      (cons (car coll) (filter pred (cdr coll)))
      (filter pred (cdr coll)))))

(map [func coll]
  (if (empty? coll)
    coll
    (cons (func (car coll)) (map func (cdr coll)))))

(get-in [indexes lst]
  (def current (nth lst (car indexes)))
  (if (empty? (cdr indexes))
    current
    (get-in (cdr indexes) current)))

(find-nearby-pills
  [dirs coord distance]
  (filter (lambda [dir] (pill? (look-to-the dir coord distance))) dirs))

(find-pills
  [dirs]
  (def near-pills (find-nearby-pills dirs lman-coord 1))
  (if (empty? near-pills)
    (find-nearby-pills dirs lman-coord 2)
    near-pills))

(available-moves
  [dirs]
  ;; Check in opposite order of pills to maximize odds of finding a pill
  (->> dirs
       (filter #(movable? (look-to-the % lman-coord 1)))))

(x [coord]
  (col coord))

(y [coord]
  (row coord))

(row [coord]
  (cdr coord))

(col [coord]
  (car coord))

(world-map [world]
  (car world))

(look-at [coord]
  (nth (nth map (row coord)) (col coord)))

(coord=
  [a b]
  (* (= (car a) (car b))
     (= (cdr a) (cdr b))))

(step
  [last-square world]
  (def map (world-map world))
  (def lman-coord (whereami world))
  (def pills (find-pills [up right down left]))
  (def open-spaces (available-moves [left down right up]))
  (def unique-open-spaces (filter #(not (coord= (to-the % lman-coord) last-square)) open-spaces))

  (def next-move (if (empty? pills)
                   (if (empty? unique-open-spaces)
                     (car open-spaces)
                     (car unique-open-spaces))
                   (car pills)))

  '(lman-coord next-move))
