(asm abs "abs.gcc")
(asm distance "distance.gcc")
(asm % "mod.gcc")
(asm nth "nth.gcc")

(pill? [cell]
  (= cell 2))

(whereami [world]
  (nth (nth world 1) 1))

(make-coord [x y]
  (cons x y))

(to-the [dir coord]
  (if (= dir up)
    (make-coord (x coord) (dec (y coord)))
    (if (= dir right)
      (make-coord (inc (x coord)) (y coord))
      (if (= dir down)
        (make-coord (x coord) (inc (y coord)))
        (if (= dir left)
          (make-coord (dec (x coord)) (y coord))
          ;; We have to have an else or the compiler dies. If the direction is
          ;; invalid, just return the given coord.
          coord)))))

(x [coord]
  (col coord))

(y [coord]
  (row coord))

(row [coord]
  (cdr coord))

(col [coord]
  (car coord))

(world-map [world]
  (car world))

(look-at [world coord]
  (nth (nth (world-map world) (row coord)) (col coord)))

(step [state world]
  '(state (if (pill? (look-at world (to-the right (whereami world))))
            right
            left)))
